package handler

import (
	"net/http"

	"github.com/gin-gonic/gin"
	
	"zpmeow/internal/application"
	"zpmeow/internal/domain"
	"zpmeow/internal/infra"
	"zpmeow/internal/infra/logger"
	"zpmeow/internal/shared"
)

// NewsletterHandler handles newsletter-related operations
type NewsletterHandler struct {
	sessionService session.SessionService
	meowService    service.MeowService
	logger         logger.Logger
}

// NewNewsletterHandler creates a new newsletter handler
func NewNewsletterHandler(sessionService session.SessionService, meowService service.MeowService) *NewsletterHandler {
	return &NewsletterHandler{
		sessionService: sessionService,
		meowService:    meowService,
		logger:         logger.GetLogger().Sub("newsletter-handler"),
	}
}

// Helper function to resolve session ID from path parameter
func (h *NewsletterHandler) resolveSessionID(c *gin.Context) (string, bool) {
	sessionID := c.Param("sessionId")
	if sessionID == "" {
		RespondWithError(c, http.StatusBadRequest, "Session ID is required")
		return "", false
	}

	// Check if session exists
	_, err := h.sessionService.GetSession(c.Request.Context(), sessionID)
	if err != nil {
		RespondWithError(c, http.StatusNotFound, "Session not found", err.Error())
		return "", false
	}

	return sessionID, true
}

// @Summary List subscribed newsletters
// @Description Get all newsletters that the WhatsApp session is subscribed to
// @Tags newsletter
// @Accept json
// @Produce json
// @Param sessionId path string true "Session ID or Name"
// @Success 200 {object} application.NewsletterResponse
// @Failure 404 {object} utils.ErrorResponse
// @Failure 500 {object} utils.ErrorResponse
// @Router /session/{sessionId}/newsletter/list [get]
func (h *NewsletterHandler) ListNewsletters(c *gin.Context) {
	sessionID, ok := h.resolveSessionID(c)
	if !ok {
		return
	}

	h.logger.Infof("Getting newsletter list for session %s", sessionID)

	newsletters, err := h.meowService.GetSubscribedNewsletters(c.Request.Context(), sessionID)
	if err != nil {
		h.logger.Errorf("Failed to get newsletters: %v", err)
		RespondWithError(c, http.StatusInternalServerError, "Failed to get newsletters", err.Error())
		return
	}

	// Convert to response format
	var newsletterList []application.NewsletterMetadata
	for _, newsletter := range newsletters {
		var picture, preview string
		if newsletter.ThreadMeta.Picture != nil {
			picture = newsletter.ThreadMeta.Picture.URL
		}
		if newsletter.ThreadMeta.Preview.URL != "" {
			preview = newsletter.ThreadMeta.Preview.URL
		}

		newsletterList = append(newsletterList, application.NewsletterMetadata{
			ID:          newsletter.ID.String(),
			Name:        newsletter.ThreadMeta.Name.Text,
			Description: newsletter.ThreadMeta.Description.Text,
			Handle:      newsletter.ThreadMeta.InviteCode,
			Picture:     picture,
			Preview:     preview,
			Reaction:    "", // Not available in current structure
			Verified:    string(newsletter.ThreadMeta.VerificationState) == "VERIFIED",
		})
	}

	response := application.NewsletterResponse{
		Newsletter: newsletterList,
	}

	RespondWithJSON(c, http.StatusOK, response)
}
